Dans ce fichier de Conception, nous allons revenir étape par étape 
sur la construction de notre projet, en clarifiant les choix principaux
que nous avons fait, lors de la création et l'implémentation des classes
composant le programme. 

//VECTEUR3D
La première classe que nous avons définie est la classe Vecteur3D. 
Nous avons fait le choix de lui donner comme attributs un array<double,3> 
de manière à pouvoir faire des boucles facilement, lorsque nous traitons 
plusieurs vecteurs à la fois. 
Pour le constructeur, il a été défini de manière à pouvoir initialiser un 
vecteur en lui donnant trois coordonnées, ou en l'initialisant par défaut
au vecteur nul, vecteur qui nous semblait le plus cohérent. 
Etant donné que nous allons retrouver les Vecteur3D dans nos futures classes
nous y avons défini des setter et des getter, nous donnant accès aux 
coordonnées de notre array, même hors de la classe. 
Enfin, les autres méthodes implémentées permettent des opérations de bases 
sur les vecteurs, vues en mathématiques, comme l'addition, la multiplication
scalaire ou le produit scalaire, méthode que nous avons par la suite 
"transformées" en opérateur, pour faciliter leur utilisation. 

//PARTICULE
La seconde classe créée est la classe Particule. 
Pour la modélisation de nos particules, nous avons donné comme attribut 
deux Vecteur3D, un pour la position, et un pour la vitesse, ainsi qu'un double
correspondant à la masse. 
En ce qui concerne les différentes méthodes, nous retrouvons une méthode 
d'affichage, permettant par la suite la définition de l'opérateur << pour les 
particules, ainsi que des setter et getter pour leur position et vitesse, ainsi 
qu'un getter pour la masse (utilisé uniquement pour l'initialisation des 
particules selon la loi de Maxwell, dont nous parlons plus loin). 
Nous y avons également défini plusieurs méthodes qui nous servent à gérer les 
collisions entre les particules 
    - Une fonction test_contact qui renvoie un booléen si la distance entre 
      le centre de gravité de deux particules est inférieure à la borne EPSILON
      que nous avons choisie comme étant 1 unité d'espace (0,1 nm). 
    - Une fonction collision_particule, prenant en entrée une autre particule, 
      ainsi qu'un Générateur aléatoire (classe définie plus tard). Elle utilise 
      la fonction test_contact pour vérifier si la particule donnée, et celle 
      actuellement étudiée se touchent, puis modifie leurs vitesses, avec 
      conservation de la quantité de mouvement et de l'énergie cinétique, mais 
      avec une direction tirée aléatoirement mais uniformément (d'où la présence
      d'un 'générateur aléatoire'). 
      Toujours concernant cette méthode, dans un exercice à rendre, les directions
      normalement tirées aléatoirement doivent être fixées. Pour cette raison, 
      nous lui donnons en argument supplémentaire un booléen. Si il est true, 
      les directions sont fixées, sinon, elles sont tirées aléatoirement comme 
      présentées précédemment. 
    - Enfin, pour une deuxième modélisation de collision entre particules, nous 
      avons créé la méthode pos_floor, qui renvoie un array<int,3>, composé
      simplement de la partie entière des coordonnées de la particule étudiée. 
Cette classe est très générale, car elle permet d'initialiser une particule avec 
une masse choisie par l'utilisateur. Cependant, pour une modélisation plus réelle, 
nous avons créé plusieurs sous classe, Néon, Argon et Hélium, à qui nous avons 
simplement attribué des masses fixes, et aussi modifié légèrement l'affichage. 
En vue d'une représentation graphique, nous retrouvons une méthode virtuelle 
dessine_sur, que nous utiliserons pour un affichage textuel (classe TextViewer). 

//ENCEINTE
Comme son nom l'indique, celle classe servira de limite virtuelle au déplacement 
des particules dans l'espace. 
Elle a pour attribut 3 double, qui une fois choisis ne pourront être modifiés.
Nous avons fait un tel choix, car nous ne sommes pas allés suffisament loin dans 
la modélisation physique, pour offrir la possibilité de déplacer une ou plusieurs 
paroi de l'enceinte pendant l'expérience. L'enceinte par défaut est un cube de 
20 unités d'espace de coté. 
Les méthodes proposées par cette classe sont des getter, notamment utilisé dans 
le cadre de la collision des particules avec les parois (gérée dans la classe 
Systeme). 
Elle peut également être affichée grâce à l'opérateur <<, en donnant les 
dimensions de l'enceinte. 
Enfin, elle peut également être représentée graphiquement, d'où la présence de 
la méthode virtuelle dessine_sur. 

//GRAPHISME 
Cette partie regroupe plusieurs classes. 
La classe principale est la classe Dessinable. Dans cette classe, nous retrouvons 
la définition virtuelle pure de dessine_sur, déjà rencontré dans plusieurs classes. 
C'est pour cette méthode que de nombreuses classes sont définies comme héritant de 
Dessinable. Le constructeur, destructeur et les méthodes de déplacement, copie et 
affectation ont été définie par défaut. 
La deuxième classe liée au graphisme est SupportADessin. Cette dernière regroupe 
les fonctions dessine() de toutes les classes que nous souhaitons représenter. 
Elles sont définies comme virtuelles pures car elle seront override dans les 
sous classe de SupportADessin, selon le type d'affichage voulu. 
Nous ne souhaitons par pouvoir déplacer ni copier de SupportADessin, donc ces 
méthodes ont été delete, et celle liées au constructeur et destructeur sont 
définies par défaut, car cette classe est abstraite, et nous ne devrions pas avoir
besoin de l'utiliser directement, mais plutôt les sous classes qui en hérite. 
Une de ces sous classes est la classe TextViewer, qui offre un affichage textuel. 
Cette classe a donc pour attribut une référence sur un ostream (choix naturel pour
un affichage en version texte). Nous avons fait le choix de construire par défaut 
un TextViewer avec l'ostream cout, mais il est possible d'en choisir un autre si 
nécessaire. Les redéfinitions des méthodes dessine() associée à toutes les classes
dessinables viennent simplement faire appel aux opérateur << de ces mêmes classes, 
en utilisant l'ostream donné en attribut. 

//GENERATEUR ALEATOIRE
Comme évoqué plusieurs fois dans d'autres cas, nous allons avoir besoin de faire 
appel à un certain aléatoire. C'est pour cette raison qu'existe la classe 
GenerateurAleatoire. 


//SYSTEME
Cette classe est sans aucun doute la plus massive, car elle représente le systeme 
modélisé dans son intégralité. Nous y trouvons comme premier attribut une Enceinte, 
déclaré comme const car, comme expliqué dans la classe Enceinte, une fois définie, 
nous ne modifions pas les dimensions de celle ci. Le second attribut est un 
tableau dynamique, vector, de unique_ptr sur des Particule. Le choix du vector est 
motivée par le fait que le nombre de particules est choisi au moment de la construction
du système, et peut être modifié si besoin. Quant au choix d'utiliser des unique_ptr, 
il provient de plusieurs points: 
    - Dans un premier temps, nous avons besoin d'utiliser des pointeurs sur des particules, 
      pour pouvoir appliquer le polymorphisme, et utiliser les méthodes des sous classes 
      de Particule, dans les cas (principaux) où les particules étudiées sont d'une espèce
      choisie. 
    - Dans un second temps, sachant que chaque particule est unique, même si plusieurs 
      sont d'une même espèce, nous ne voulons pas que plusieurs pointeurs pointent sur 
      une même particule. 
En prenant cela en compte, ainsi que pour protéger la mémoire, les unique_ptr nous semblaient
être la meilleur option. 
      