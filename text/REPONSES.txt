P1.1)
Nous avons représenté leurs coordonnées comme un array de taille 3. Cela nous
permet de plus facilement travailler avec des boucles, l'inconvenient est
qu'il y a la possibilité de mal indexer ces array, mais nous allons gérer ces
situations avec des messages d'erreur ou des exceptions (try, throw).
Pour l'instant nous avons un attribut privé, l'array en question, et 4 méthodes
publiques, set_coord, get_coord, affiche et compare, toutes expliquées dans le
fichier Vecteur3D.h. Nous avons suivi les consignes données mais la méthode en
plus (get_coord) est nécessaire car nous avons choisi de mettre l'array des
composantes comme attribut privé.

P4.1)
Nous n'avons pas ajouté de constructeur de copie. Comme le seul attribut d'un
vecteur est un array, alors le constructeur de copie par défaut fonctionne très
bien.

P4.2)
Si l'on devait définir un constructeur en coordonnées sphériques, il n'y aurait
aucune différence au niveau des attributs, on peut simplement convertir de
sphériques à cartésiennes. Il y aura un conflit avec le constructeur en
coordonnées cartésiennes car on aurait les mêmes entrées, mais cela peut être
résolu avec un booléen en plus comme entrée. Au final, rajouter l'option
d'initialiser en spheriques ne pose pas de problème et pourrait même être très
utile !

P4.3)
Nous avons introduit de nombreux opérateurs:
    -les opérateurs += et -=; //incrémentation et décrémentation
    -les opérateurs + et -; //addition et soustraction
    -les opérateurs == et !=; //comparaison
    -les opérateurs *= et /=; //multiplication et division scalaire
    -les opérateurs * et /; // idem mais pour retourner un vecteur
    -l'opérateur *; //produit scalaire
    -l'opérateur ^=; //le produit vectoriel d'un vecteur avec lui même
    -l'opérateur ^; //produit vectoriel
    -l'opérateur ~; //vecteur unitaire
    -l'opérateur -; //l'inverse d'un vecteur

P7.1)
la méthode dessine_sur est, pour la classe Dessinable, une methode virtuelle
qui sera héritée et "overridée" par les differents objets dessinables du systeme
(partiucle, enceinte, ...). Dessinable sera une classe abstraite, car on utilisera
les méthodes d'affichage prédéfinies dans les sous-classes de Dessinable et dans
les différentes sous-classes de SupportADessin pour les dessiner.

P8.1)
Il faut faire attention aux copies (surface ou profonde), le concept d'unicité
ou non (unique_ptr) et tout ce qui est liée a l'allocation et la déallocation de
mémoire. Il faudra aussi prendre en compte la structure des méthodes si l'on
cherche a faire du polymorphisme, il faut que les methodes soient
virtuelles et prennent en compte qu'on travaille avec des pointeurs !

P8.2)
Notre classe étant dessinable, elle va hériter de la classe Dessinable, et de sa 
méthode virutelle "dessine_sur". 
De plus, le système sera composé d'une enceinte, et d'un ensemble de particules. 
Ainsi, les attributs de la classe Systeme sont un pointeur sur une instance de la 
classe Enceinte, ainsi qu'un tableau dynamique (vector) de pointeurs sur des 
instances de la classe Particule. 
Nous utilisons des pointeurs afin de réaliser du polymorphisme, notamment au niveau 
des différentes particules, car les sous classes associées possèdent des méthodes 
différentes de la super classe Particule. 

P8.3) 
Pour empêcher totalement la copie et l'affectation des instances de la classe Systeme, 
nous allons utiliser la commande "delete" offerte par c++11. 

P9.1)


P9.2)
Si on pose n le nombre de particules dans notre système, alors étant donné que l'on 
compare les positions d'une particule par rapport à toutes les autres, la complexité
de l'algorithme est en grand_théta(n). Maintenant, si nous faisons cela pour toute les
particules (et en supposant que une fois qu'une particule a été comparée à toutes les
autres, on ne répète pas l'opération lorsque l'on fait cette comparaison depuis une 
autre particule), nous aurons un algorithme en grand_théta(n!). 
